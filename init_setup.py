# -*- coding: utf-8 -*-
"""프로젝트 자동 생성 스크립트 (Python)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Sax5bfcSar_WOQrViwjkzDyjBKH2sEC8
"""

import os
import textwrap

# ----------------------------------------------------------------------
# 이 스크립트는 'ai-assist-google' 프로젝트의 전체 디렉토리 구조와
# 모든 필수 파일을 자동으로 생성합니다.
#
# 사용 방법:
# 1. 이 파일을 'create_project.py'로 저장합니다.
# 2. 터미널을 열고 이 파일이 있는 위치로 이동합니다.
# 3. 'python create_project.py' 명령을 실행합니다.
# 4. 'ai-assist-google' 디렉토리가 생성되며, 모든 파일이 준비됩니다.
# ----------------------------------------------------------------------

# --- 파일 내용 정의 ---

# 각 파일의 내용은 여기에 다중 라인 문자열로 정의됩니다.
# 이 내용은 대화에서 생성된 코드들을 기반으로 합니다.

README_MD_CONTENT = """
# AI 업무 자동화 비서 (ai-assist-google)

본 프로젝트는 Google AI(Gemini), Gmail, Google Calendar와 연동하여 반복적인 업무를 자동화하는 AI 비서 서비스입니다. LangChain/LangGraph를 활용한 Multi-Agent 아키텍처를 기반으로 사용자 요청의 의도를 파악하고, RAG를 통해 내부 문서를 참조하여 정확하고 풍부한 답변을 제공합니다. 사용자는 Streamlit으로 구현된 웹 UI를 통해 AI 비서와 대화할 수 있습니다.

## 🚀 프로젝트 아키텍처

1.  **Frontend (Streamlit)**: 사용자가 AI와 상호작용하는 웹 인터페이스입니다. 사용자의 메시지를 백엔드 API로 전송하고, 스트리밍 응답을 받아 화면에 표시합니다.
2.  **Backend (FastAPI)**: Streamlit 앱의 요청을 받아 처리하는 API 서버입니다.
3.  **Master Agent (LangGraph)**: 사용자의 질문을 가장 먼저 받아 의도를 분석하고, 어떤 전문가 에이전트(Specialist Agent)에게 작업을 위임할지 결정하는 오케스트레이터 역할을 합니다.
4.  **Specialist Agents (LangChain)**: 특정 도메인의 작업을 수행하는 에이전트들입니다.
    * **Gmail Agent**: Google Gmail API를 사용하여 메일 요약, 검색, 분류 등의 작업을 수행합니다.
    * **Calendar Agent**: Google Calendar API를 사용하여 일정 조회, 요약 등의 작업을 수행합니다.
    * **RAG Agent**: FAISS 기반의 Vector DB에 저장된 내부 문서(보고서, 매뉴얼 등)를 검색하여 질문에 답변합니다.
5.  **Tools**: 각 에이전트가 사용하는 도구입니다. 실제 Google API를 호출하거나 Vector DB를 검색하는 함수들로 구성됩니다.
6.  **Vector Store (FAISS)**: RAG를 위해 텍스트 문서들이 임베딩되어 저장되는 공간입니다.
"""
## 📁 디렉토리 구조

"""
ai-assist-google/
├── app/
│   ├── app.py              # Streamlit 프론트엔드 애플리케이션
│   └── requirements.txt    # 프론트엔드 파이썬 패키지
├── server/
│   ├── api/
│   │   └── chat.py         # /chat API 엔드포인트 (FastAPI 라우터)
│   ├── agents/
│   │   ├── __init__.py
│   │   ├── master_agent.py # 작업을 라우팅하는 메인 에이전트 (LangGraph)
│   │   ├── specialist_agents.py # Gmail, Calendar, RAG 에이전트 정의
│   │   └── state.py        # LangGraph 상태 정의
│   ├── core/
│   │   └── config.py       # 환경변수 로드
│   ├── rag/
│   │   ├── __init__.py
│   │   ├── ingest.py       # 문서를 로드하고 Vector DB에 저장하는 스크립트
│   │   └── retriever.py    # Vector DB에서 문서를 검색하는 로직
│   ├── tools/
│   │   ├── __init__.py
│   │   └── google_services.py # Gmail, Calendar API 호출 함수 (Tools)
│   ├── main.py             # FastAPI 애플리케이션 진입점
│   └── requirements.txt    # 백엔드 파이썬 패키지
├── vector_store/
│   └── faiss_index/        # FAISS 인덱스가 저장될 디렉토리
│       └── .gitkeep
├── documents/
│   └── sample_report.txt   # RAG로 사용할 샘플 문서
├── .env.example            # 환경변수 설정 예시 파일
└── README.md               # 프로젝트 안내 문서
```

## 셋업 및 실행 방법

### 1. Google Cloud 및 API 설정

1.  **Google Cloud Project 생성**: Google Cloud Console에서 새 프로젝트를 생성합니다.
2.  **API 활성화**: 생성한 프로젝트에서 다음 API를 활성화합니다.
    * `Vertex AI API` (또는 `Generative Language API`)
    * `Gmail API`
    * `Google Calendar API`
3.  **API 키 생성**: `API 및 서비스` > `사용자 인증 정보`에서 **API 키**를 생성합니다. 이 키는 Google AI 모델 호출에 사용됩니다.
4.  **OAuth 2.0 클라이언트 ID 생성**:
    * `API 및 서비스` > `OAuth 동의 화면`에서 필요한 정보를 입력하고 동의 화면을 구성합니다. (테스트 목적일 경우 '테스트 사용자'에 본인 Google 계정 추가)
    * `사용자 인증 정보`에서 **OAuth 2.0 클라이언트 ID**를 생성합니다.
    * 생성된 인증 정보(JSON 파일)를 다운로드하여 프로젝트 루트에 `credentials.json` 이름으로 저장합니다.

### 2. 프로젝트 환경 설정

1.  **저장소 복제 및 `.env` 파일 생성**:
    ```bash
    git clone <repository_url>
    cd ai-assist-google
    cp .env.example .env
    ```
2.  `.env` 파일에 1단계에서 얻은 정보를 입력합니다.

### 3. RAG 데이터 준비

1.  `documents` 디렉토리에 AI가 참조할 텍스트 파일(예: `.txt`, `.pdf`, `.md`)을 추가합니다.
2.  아래 명령어를 실행하여 문서를 Vector DB에 저장합니다.
    ```bash
    # (가상환경 활성화 후)
    pip install -r server/requirements.txt
    python -m server.rag.ingest
    ```vector_store/faiss_index` 디렉토리에 인덱스 파일이 생성됩니다.

### 4. 애플리케이션 실행

1.  **백엔드 서버 실행**:
    ```bash
    # (가상환경 활성화 후)
    # pip install -r server/requirements.txt # 이미 설치했다면 생략
    uvicorn server.main:app --host 0.0.0.0 --port 8000 --reload
    ```
2.  **프론트엔드 앱 실행** (새 터미널에서):
    ```bash
    # (가상환경 활성화 후)
    pip install -r app/requirements.txt
    streamlit run app/app.py
    ```
3.  웹 브라우저에서 `http://localhost:8501` 주소로 접속하여 AI 비서와 대화를 시작합니다.
'''

ENV_EXAMPLE_CONTENT = '''
# Google AI (Gemini)
# https://aistudio.google.com/app/apikey 에서 API 키를 발급받으세요.
GOOGLE_API_KEY="YOUR_GOOGLE_API_KEY"

# 사용할 Google AI 모델 이름
GEMINI_MODEL_NAME="gemini-1.5-flash-latest"

# RAG 관련 설정
EMBEDDING_MODEL_NAME="text-embedding-004"
VECTOR_STORE_PATH="./vector_store/faiss_index"
DOCUMENT_SOURCE_DIR="./documents"

# Google OAuth
# Google Cloud Console에서 다운로드한 credentials.json 파일의 경로
GOOGLE_CREDENTIALS_PATH="./credentials.json"
# OAuth 토큰이 저장될 경로
TOKEN_PATH="./token.json"
# OAuth 리디렉션 URI (로컬 테스트용)
REDIRECT_URI="http://localhost:8501"
'''

APP_PY_CONTENT = '''
# app/app.py
import streamlit as st
import requests
import json

# --- 페이지 설정 ---
st.set_page_config(
    page_title="AI 업무 자동화 비서",
    page_icon="🤖",
    layout="wide"
)

# --- 백엔드 API 주소 ---
BACKEND_API_URL = "http://localhost:8000/api/chat"

# --- UI 구성 ---
st.title("🤖 AI 업무 자동화 비서")
st.markdown('''
안녕하세요! 저는 당신의 업무를 돕는 AI 비서입니다.  
메일 정리, 일정 확인, 문서 요약 등 다양한 작업을 요청해보세요.

**예시 질문:**
- "오늘 내 캘린더에 무슨 일정이 있어?"
- "AI 관련해서 새로 온 메일 찾아줘"
- "최신 AI 기술 보고서 요약해줘"
''')

# --- 세션 상태 초기화 ---
# 'messages'는 채팅 기록을 저장합니다.
if "messages" not in st.session_state:
    st.session_state.messages = []

# --- 채팅 기록 표시 ---
# 이전 대화 내용을 화면에 표시합니다.
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# --- 사용자 입력 처리 ---
# st.chat_input을 사용하여 사용자로부터 입력을 받습니다.
if prompt := st.chat_input("무엇을 도와드릴까요?"):
    # 사용자가 입력한 메시지를 채팅 기록에 추가하고 화면에 표시합니다.
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.markdown(prompt)

    # AI의 응답을 표시할 준비를 합니다.
    with st.chat_message("assistant"):
        message_placeholder = st.empty()
        message_placeholder.markdown("생각 중...")

        try:
            # 백엔드 API에 요청을 보냅니다.
            # 대화 기록을 함께 보내 문맥을 유지하도록 합니다.
            history = [
                (msg["content"], st.session_state.messages[i+1]["content"])
                for i, msg in enumerate(st.session_state.messages)
                if msg["role"] == "user" and i + 1 < len(st.session_state.messages)
            ]
            
            response = requests.post(
                BACKEND_API_URL,
                json={"message": prompt, "history": history}
            )
            response.raise_for_status()  # HTTP 오류 발생 시 예외 처리

            # API 응답을 받아 화면에 표시합니다.
            ai_response = response.json()["response"]
            message_placeholder.markdown(ai_response)
            
            # AI의 응답을 채팅 기록에 추가합니다.
            st.session_state.messages.append({"role": "assistant", "content": ai_response})

        except requests.exceptions.RequestException as e:
            message_placeholder.error(f"백엔드 서버와 통신 중 오류가 발생했습니다: {e}")
        except Exception as e:
            message_placeholder.error(f"예상치 못한 오류가 발생했습니다: {e}")
'''

APP_REQUIREMENTS_TXT_CONTENT = '''
streamlit
requests
'''

SERVER_MAIN_PY_CONTENT = '''
# server/main.py
import uvicorn
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from server.api import chat

# FastAPI 애플리케이션 생성
app = FastAPI(
    title="AI Assist Google - Backend",
    description="AI 업무 자동화 비서를 위한 백엔드 API 서버",
    version="1.0.0"
)

# CORS 미들웨어 설정
# 개발 환경에서는 모든 오리진을 허용하여 Streamlit 앱과의 통신을 원활하게 합니다.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 실제 프로덕션 환경에서는 보안을 위해 특정 도메인만 허용하세요.
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# API 라우터 포함
app.include_router(chat.router, prefix="/api", tags=["Chat"])

@app.get("/", tags=["Root"])
async def read_root():
    '''
    루트 엔드포인트. API 서버가 정상적으로 실행 중인지 확인합니다.
    '''
    return {"message": "AI Assist Google Backend is running."}

if __name__ == "__main__":
    # 이 파일을 직접 실행할 경우 Uvicorn 서버를 시작합니다.
    # 실제 배포 시에는 'uvicorn server.main:app --host 0.0.0.0 --port 8000' 명령어를 사용합니다.
    uvicorn.run(app, host="0.0.0.0", port=8000)
'''

SERVER_REQUIREMENTS_TXT_CONTENT = '''
fastapi
uvicorn[standard]
langchain
langgraph
langchain-google-genai
google-api-python-client
google-auth-httplib2
google-auth-oauthlib
faiss-cpu
langchain-community
pydantic-settings
python-dotenv
tiktoken
'''

API_CHAT_PY_CONTENT = '''
# server/api/chat.py
from fastapi import APIRouter
from pydantic import BaseModel
from typing import List, Tuple
from server.agents.master_agent import get_agent_executor

# API 라우터 생성
router = APIRouter()

# 요청 본문(Request Body) 모델 정의
class ChatRequest(BaseModel):
    message: str
    history: List[Tuple[str, str]] # (human_message, ai_message) 형태의 리스트

# 응답 본문(Response Body) 모델 정의
class ChatResponse(BaseModel):
    response: str

@router.post("/chat", response_model=ChatResponse)
async def handle_chat(request: ChatRequest):
    '''
    사용자의 채팅 메시지를 받아 AI 에이전트의 응답을 반환하는 엔드포인트.
    '''
    try:
        # LangGraph로 구성된 에이전트 실행기(executor)를 가져옵니다.
        agent_executor = get_agent_executor()
        
        # 사용자의 메시지와 대화 기록을 입력으로 에이전트를 실행합니다.
        # LangChain의 invoke 메소드는 에이전트의 최종 결과를 반환합니다.
        result = agent_executor.invoke({
            "messages": [("user", request.message)],
            "history": request.history
        })
        
        # 결과에서 AI의 마지막 응답을 추출합니다.
        # LangGraph의 결과는 'messages' 키에 대화 흐름 전체를 담고 있습니다.
        ai_response = result['messages'][-1].content
        
        return ChatResponse(response=ai_response)
    except Exception as e:
        # 에러 발생 시 로그를 남기고, 사용자에게 에러 메시지를 반환할 수 있습니다.
        print(f"Error during chat processing: {e}")
        return ChatResponse(response=f"죄송합니다, 요청을 처리하는 중 오류가 발생했습니다: {e}")
'''

AGENTS_STATE_PY_CONTENT = '''
# server/agents/state.py
from typing import TypedDict, Annotated, List
from langchain_core.messages import BaseMessage
import operator

class AgentState(TypedDict):
    '''
    LangGraph의 상태를 나타내는 TypedDict입니다.
    - messages: 대화의 흐름을 나타내는 메시지 리스트
    - history: 이전 대화 기록
    '''
    messages: Annotated[List[BaseMessage], operator.add]
    history: list
'''

AGENTS_MASTER_AGENT_PY_CONTENT = '''
# server/agents/master_agent.py
from langgraph.graph import StateGraph, END
from .specialist_agents import (
    create_gmail_agent,
    create_calendar_agent,
    create_rag_agent,
    create_general_agent
)
from .state import AgentState
from ..tools.google_services import get_google_services_tools
from ..rag.retriever import get_rag_retriever

# --- 1. 에이전트 및 도구 준비 ---
# 각 전문 에이전트와 도구를 생성합니다.
gmail_tools = get_google_services_tools(['gmail'])
calendar_tools = get_google_services_tools(['calendar'])
rag_retriever = get_rag_retriever()

gmail_agent = create_gmail_agent(gmail_tools)
calendar_agent = create_calendar_agent(calendar_tools)
rag_agent = create_rag_agent(rag_retriever)
general_agent = create_general_agent()

# --- 2. LangGraph 노드 정의 ---

def general_agent_node(state: AgentState):
    '''일반 대화 노드'''
    result = general_agent.invoke(state)
    return {"messages": [result]}

def gmail_agent_node(state: AgentState):
    '''Gmail 관련 작업 처리 노드'''
    result = gmail_agent.invoke(state)
    return {"messages": [result]}

def calendar_agent_node(state: AgentState):
    '''Google Calendar 관련 작업 처리 노드'''
    result = calendar_agent.invoke(state)
    return {"messages": [result]}

def rag_agent_node(state: AgentState):
    '''RAG 기반 질의응답 처리 노드'''
    result = rag_agent.invoke(state)
    # RAG 체인은 dict가 아닌 content를 직접 반환하므로, BaseMessage로 래핑해야 합니다.
    from langchain_core.messages import AIMessage
    return {"messages": [AIMessage(content=result)]}


# --- 3. 라우팅 로직 정의 ---

def route_message(state: AgentState):
    '''사용자 메시지의 의도를 파악하여 적절한 전문가 에이전트로 라우팅'''
    last_message = state['messages'][-1]
    message_content = last_message.content.lower()

    if "메일" in message_content or "gmail" in message_content:
        return "gmail_agent"
    elif "일정" in message_content or "캘린더" in message_content or "calendar" in message_content:
        return "calendar_agent"
    # '보고서', '문서' 등 RAG가 필요한 키워드를 추가할 수 있습니다.
    elif "보고서" in message_content or "문서" in message_content or "요약" in message_content:
        # 이 부분은 더 정교한 LLM 기반 라우팅으로 개선할 수 있습니다.
        return "rag_agent"
    else:
        return "general_agent"

# --- 4. 그래프(Graph) 구성 ---

def get_agent_executor():
    '''LangGraph 워크플로우를 생성하고 컴파일하여 실행기를 반환합니다.'''
    workflow = StateGraph(AgentState)

    # 노드 추가
    workflow.add_node("general_agent", general_agent_node)
    workflow.add_node("gmail_agent", gmail_agent_node)
    workflow.add_node("calendar_agent", calendar_agent_node)
    workflow.add_node("rag_agent", rag_agent_node)

    # 진입점(Entry Point)에서 라우팅 로직으로 연결
    workflow.set_entry_point("router")
    workflow.add_node("router", route_message)

    workflow.add_conditional_edges(
        "router",
        lambda x: x, # 라우터 함수의 반환값을 그대로 사용
        {
            "general_agent": "general_agent",
            "gmail_agent": "gmail_agent",
            "calendar_agent": "calendar_agent",
            "rag_agent": "rag_agent",
        },
    )

    # 각 전문가 에이전트 노드 실행 후에는 종료(END)
    workflow.add_edge("general_agent", END)
    workflow.add_edge("gmail_agent", END)
    workflow.add_edge("calendar_agent", END)
    workflow.add_edge("rag_agent", END)

    # 그래프 컴파일
    return workflow.compile()
'''

AGENTS_SPECIALIST_AGENTS_PY_CONTENT = '''
# server/agents/specialist_agents.py
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain.chains import create_retrieval_chain
from langchain.chains.combine_documents import create_stuff_documents_chain
from server.core.config import settings

# --- 공통 LLM 초기화 ---
llm = ChatGoogleGenerativeAI(
    model=settings.GEMINI_MODEL_NAME,
    google_api_key=settings.GOOGLE_API_KEY,
    temperature=0.7,
    convert_system_message_to_human=True # Gemini는 system message를 user message로 변환해야 함
)

# --- 1. 일반 대화 에이전트 ---
def create_general_agent():
    '''
    특별한 도구 없이 대화하는 기본 에이전트.
    '''
    prompt = ChatPromptTemplate.from_messages([
        ("system", "당신은 친절하고 유능한 AI 비서입니다. 사용자의 질문에 명확하고 간결하게 답변하세요."),
        MessagesPlaceholder(variable_name="history"),
        ("user", "{messages}"),
    ])
    chain = prompt | llm
    return chain

# --- 2. ReAct (Tool-Calling) 기반 에이전트 생성 함수 ---
def create_react_agent(tools, system_prompt):
    '''
    주어진 도구와 프롬프트를 사용하여 ReAct(Tool-Calling) 에이전트를 생성합니다.
    '''
    prompt = ChatPromptTemplate.from_messages([
        ("system", system_prompt),
        MessagesPlaceholder(variable_name="history"),
        ("user", "{messages}"),
        MessagesPlaceholder(variable_name="agent_scratchpad"),
    ])
    agent = create_tool_calling_agent(llm, tools, prompt)
    executor = AgentExecutor(agent=agent, tools=tools, verbose=True)
    return executor

# --- 3. 전문가 에이전트 생성 ---
def create_gmail_agent(tools):
    '''Gmail 관련 작업을 처리하는 에이전트'''
    system_prompt = "당신은 Gmail 전문가입니다. 사용자의 요청에 따라 메일을 검색하고, 요약하고, 관련 정보를 제공하세요."
    return create_react_agent(tools, system_prompt)

def create_calendar_agent(tools):
    '''Google Calendar 관련 작업을 처리하는 에이전트'''
    system_prompt = "당신은 Google Calendar 전문가입니다. 사용자의 요청에 따라 일정을 조회하고, 요약하여 알려주세요."
    return create_react_agent(tools, system_prompt)

# --- 4. RAG 에이전트 (Retriever-Augmented Generation) ---
def create_rag_agent(retriever):
    '''
    내부 문서를 검색하여 답변을 생성하는 RAG 에이전트.
    이 에이전트는 ReAct가 아닌 Retrieval Chain을 사용합니다.
    '''
    system_prompt = (
        "당신은 문서 검색 및 요약 전문가입니다."
        "주어진 문서(context)를 기반으로 사용자의 질문에 답변하세요."
        "문서에 없는 내용은 답변하지 말고, 정보가 없다고 솔직하게 말하세요."
        "\\n\\n"
        "{context}"
    )
    prompt = ChatPromptTemplate.from_messages([
        ("system", system_prompt),
        MessagesPlaceholder(variable_name="history"),
        ("user", "{input}"), # Retrieval Chain은 'input'을 키로 사용
    ])
    
    # 문서를 프롬프트에 채워넣는 체인
    question_answer_chain = create_stuff_documents_chain(llm, prompt)
    
    # 리트리버와 답변 생성 체인을 결합
    rag_chain = create_retrieval_chain(retriever, question_answer_chain)
    
    # LangGraph와 호환되도록 입력/출력 형식을 맞춤
    # 'messages'에서 사용자 입력을 추출하여 'input'으로 전달
    def invoke_rag_chain(state):
        last_user_message = state['messages'][-1].content
        history = state.get('history', [])
        result = rag_chain.invoke({"input": last_user_message, "history": history})
        return result.get('answer', "죄송합니다, 답변을 생성할 수 없습니다.")

    return invoke_rag_chain
'''

CORE_CONFIG_PY_CONTENT = '''
# server/core/config.py
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    '''
    .env 파일로부터 환경 변수를 로드하는 설정 클래스입니다.
    '''
    GOOGLE_API_KEY: str
    GEMINI_MODEL_NAME: str = "gemini-1.5-flash-latest"
    EMBEDDING_MODEL_NAME: str = "text-embedding-004"
    VECTOR_STORE_PATH: str = "./vector_store/faiss_index"
    DOCUMENT_SOURCE_DIR: str = "./documents"
    GOOGLE_CREDENTIALS_PATH: str = "./credentials.json"
    TOKEN_PATH: str = "./token.json"
    REDIRECT_URI: str = "http://localhost:8501"

    model_config = SettingsConfigDict(env_file=".env", env_file_encoding='utf-8')

# 설정 객체 인스턴스화
settings = Settings()
'''

RAG_INGEST_PY_CONTENT = '''
# server/rag/ingest.py
import os
from langchain_community.document_loaders import DirectoryLoader, TextLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_google_genai import GoogleGenerativeAIEmbeddings
from langchain_community.vectorstores import FAISS
from server.core.config import settings
import sys

# 프로젝트 루트 디렉토리를 Python 경로에 추가
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))


def main():
    '''
    'documents' 디렉토리의 문서를 로드, 분할, 임베딩하여 FAISS 벡터 저장소에 저장합니다.
    '''
    print("문서 로드를 시작합니다...")
    # DirectoryLoader를 사용하여 지정된 디렉토리의 모든 .txt 파일을 로드합니다.
    loader = DirectoryLoader(
        settings.DOCUMENT_SOURCE_DIR,
        glob="**/*.txt",
        loader_cls=TextLoader,
        loader_kwargs={"encoding": "utf-8"}
    )
    documents = loader.load()
    if not documents:
        print(f"로드할 문서가 없습니다. '{settings.DOCUMENT_SOURCE_DIR}' 디렉토리를 확인하세요.")
        return

    print(f"총 {len(documents)}개의 문서를 로드했습니다.")

    print("텍스트 분할을 시작합니다...")
    # 텍스트를 의미 있는 단위로 분할합니다.
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)
    docs = text_splitter.split_documents(documents)
    print(f"총 {len(docs)}개의 청크(chunk)로 분할되었습니다.")

    print("임베딩 및 벡터 저장소 생성을 시작합니다...")
    # Google의 임베딩 모델을 초기화합니다.
    embeddings = GoogleGenerativeAIEmbeddings(
        model=f"models/{settings.EMBEDDING_MODEL_NAME}",
        google_api_key=settings.GOOGLE_API_KEY
    )

    # 분할된 문서와 임베딩 모델을 사용하여 FAISS 벡터 저장소를 생성합니다.
    db = FAISS.from_documents(docs, embeddings)

    # 생성된 벡터 저장소를 지정된 경로에 저장합니다.
    vector_store_dir = os.path.dirname(settings.VECTOR_STORE_PATH)
    if not os.path.exists(vector_store_dir):
        os.makedirs(vector_store_dir)
    db.save_local(settings.VECTOR_STORE_PATH)
    print(f"벡터 저장소가 '{settings.VECTOR_STORE_PATH}' 경로에 성공적으로 저장되었습니다.")

if __name__ == "__main__":
    main()
'''

RAG_RETRIEVER_PY_CONTENT = '''
# server/rag/retriever.py
import os
from langchain_google_genai import GoogleGenerativeAIEmbeddings
from langchain_community.vectorstores import FAISS
from server.core.config import settings

def get_rag_retriever():
    '''
    저장된 FAISS 인덱스를 로드하여 LangChain Retriever 객체를 반환합니다.
    '''
    if not os.path.exists(settings.VECTOR_STORE_PATH):
        raise FileNotFoundError(
            f"Vector store not found at {settings.VECTOR_STORE_PATH}. "
            "Please run 'python -m server.rag.ingest' first."
        )

    embeddings = GoogleGenerativeAIEmbeddings(
        model=f"models/{settings.EMBEDDING_MODEL_NAME}",
        google_api_key=settings.GOOGLE_API_KEY
    )
    
    db = FAISS.load_local(
        settings.VECTOR_STORE_PATH,
        embeddings,
        allow_dangerous_deserialization=True # FAISS 로드 시 필요
    )
    
    return db.as_retriever()
'''

TOOLS_GOOGLE_SERVICES_PY_CONTENT = '''
# server/tools/google_services.py
import os
from langchain.tools import tool
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from server.core.config import settings

# --- Google API 연동 설정 ---
# 필요한 권한 범위(SCOPES)를 정의합니다.
SCOPES = {
    'gmail': ['https://www.googleapis.com/auth/gmail.readonly'],
    'calendar': ['https://www.googleapis.com/auth/calendar.readonly']
}

def get_credentials(service_names):
    '''
    사용자 인증을 처리하고 유효한 Credentials 객체를 반환합니다.
    토큰이 없거나 만료된 경우, OAuth 2.0 흐름을 통해 새로 발급받습니다.
    '''
    creds = None
    token_path = settings.TOKEN_PATH
    
    required_scopes = []
    for service in service_names:
        required_scopes.extend(SCOPES.get(service, []))
    
    if os.path.exists(token_path):
        creds = Credentials.from_authorized_user_file(token_path, required_scopes)
    
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            # 이 부분은 Streamlit/FastAPI 환경에서 개선이 필요합니다.
            # 초기 실행 시 터미널에서 인증을 수행해야 합니다.
            flow = InstalledAppFlow.from_client_secrets_file(
                settings.GOOGLE_CREDENTIALS_PATH, required_scopes
            )
            creds = flow.run_local_server(port=0)
        
        with open(token_path, 'w') as token:
            token.write(creds.to_json())
    return creds

# --- LangChain Tool 정의 ---

@tool
def search_gmail(query: str) -> str:
    '''
    "주어진 쿼리로 Gmail을 검색하여 최근 5개 메일의 제목과 보낸 사람 목록을 반환합니다.
    예: 'AI 관련 최신 뉴스'
    '''
    try:
        creds = get_credentials(['gmail'])
        service = build('gmail', 'v1', credentials=creds)
        
        results = service.users().messages().list(userId='me', q=query, maxResults=5).execute()
        messages = results.get('messages', [])

        if not messages:
            return "해당 쿼리에 대한 메일을 찾을 수 없습니다."

        email_list = []
        for msg in messages:
            msg_data = service.users().messages().get(userId='me', id=msg['id']).execute()
            headers = msg_data['payload']['headers']
            subject = next((header['value'] for header in headers if header['name'] == 'Subject'), '제목 없음')
            sender = next((header['value'] for header in headers if header['name'] == 'From'), '발신자 불명')
            email_list.append(f"제목: {subject}\\n보낸 사람: {sender}\\n---")
        
        return "\\n".join(email_list)
    except HttpError as error:
        return f"Gmail API 호출 중 오류 발생: {error}"
    except Exception as e:
        return f"알 수 없는 오류 발생: {e}"

@tool
def get_today_calendar_events() -> str:
    '''
    "오늘의 Google Calendar 일정을 모두 가져와 요약해서 반환합니다."
    '''
    from datetime import datetime, time, timezone, timedelta

    try:
        creds = get_credentials(['calendar'])
        service = build('calendar', 'v3', credentials=creds)

        KST = timezone(timedelta(hours=9))
        now = datetime.now(KST)
        time_min = datetime.combine(now.date(), time.min, tzinfo=KST).isoformat()
        time_max = datetime.combine(now.date(), time.max, tzinfo=KST).isoformat()

        events_result = service.events().list(
            calendarId='primary', timeMin=time_min, timeMax=time_max,
            singleEvents=True, orderBy='startTime'
        ).execute()
        events = events_result.get('items', [])

        if not events:
            return "오늘 예정된 일정이 없습니다."

        event_list = ["오늘의 일정입니다:"]
        for event in events:
            start = event['start'].get('dateTime', event['start'].get('date'))
            start_dt = datetime.fromisoformat(start)
            start_str = start_dt.strftime('%H:%M') if 'dateTime' in event['start'] else '하루 종일'
            event_list.append(f"- {start_str}: {event['summary']}")
        
        return "\\n".join(event_list)
    except HttpError as error:
        return f"Calendar API 호출 중 오류 발생: {error}"
    except Exception as e:
        return f"알 수 없는 오류 발생: {e}"


def get_google_services_tools(services: list):
    '''요청된 서비스에 따라 관련된 도구 리스트를 반환합니다.'''
    tools = []
    if 'gmail' in services:
        tools.append(search_gmail)
    if 'calendar' in services:
        tools.append(get_today_calendar_events)
    return tools
'''

SAMPLE_REPORT_TXT_CONTENT = '''
2024년 AI 기술 동향 보고서

1. 서론
인공지능(AI) 기술은 전례 없는 속도로 발전하며 산업 전반에 혁신을 가져오고 있습니다. 본 보고서는 2024년 현재 AI 기술의 주요 동향을 분석하고, 향후 전망을 제시하는 것을 목적으로 합니다.

2. 주요 동향
가. 거대 언어 모델(LLM)의 고도화
- GPT-4, Gemini 등 더욱 향상된 성능의 모델들이 등장하며, 인간과 유사한 수준의 대화 및 창작 능력을 보여주고 있습니다.
- 멀티모달(Multi-modal) 기능이 강화되어 텍스트뿐만 아니라 이미지, 음성, 비디오 등 다양한 형태의 데이터를 동시에 이해하고 생성하는 능력이 중요해지고 있습니다.

나. 생성형 AI의 확산
- 텍스트, 이미지, 코드 생성을 넘어 음악, 비디오 등 다양한 콘텐츠 제작에 생성형 AI가 활용되고 있습니다.
- 기업들은 마케팅, 디자인, 소프트웨어 개발 등 다양한 업무에 생성형 AI를 도입하여 생산성을 높이고 있습니다.

다. AI 윤리 및 책임의 중요성 증대
- AI 기술의 발전과 함께 편향성, 개인정보 침해, 가짜 뉴스 등 잠재적인 위험에 대한 우려도 커지고 있습니다.
- '설명 가능한 AI(XAI)' 연구와 공정하고 투명한 AI 개발을 위한 정책 및 규제 논의가 활발하게 진행되고 있습니다.

3. 결론
2024년 AI 기술은 단순한 자동화를 넘어 인간의 창의성과 지능을 증강시키는 방향으로 발전하고 있습니다. 기업과 개인은 이러한 기술 변화에 능동적으로 대응하고, 윤리적인 활용 방안을 모색해야 할 것입니다.
'''

INTERACTIVE_DASHBOARD_HTML_CONTENT = '''
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 업무 자동화 비서 (ai-assist-google) | Interactive Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; }
        .tab-active { border-color: #0d9488; color: #0d9488; font-weight: 500; }
        .tab-inactive { border-color: transparent; }
        .content-section { display: none; }
        .content-active { display: block; }
        .component-card { transition: all 0.2s ease-in-out; }
        .component-card:hover { transform: translateY(-4px); box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); }
        .setup-step input:checked + label { text-decoration: line-through; color: #9ca3af; }
        .gemini-btn { transition: background-color 0.2s; }
        .gemini-btn:hover { background-color: #0f766e; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0d9488;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-stone-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-teal-700">AI 업무 자동화 비서</h1>
            <p class="text-lg text-gray-600 mt-2">Google 서비스와 연동된 Multi-Agent 기반 AI 솔루션</p>
        </header>

        <div class="bg-white rounded-xl shadow-lg p-4 md:p-6">
            <nav class="border-b border-gray-200 mb-6">
                <ul class="flex flex-wrap -mb-px text-sm font-medium text-center text-gray-500">
                    <li class="mr-2">
                        <button id="tab-overview" class="inline-block p-4 border-b-2 rounded-t-lg tab-active">개요</button>
                    </li>
                    <li class="mr-2">
                        <button id="tab-architecture" class="inline-block p-4 border-b-2 rounded-t-lg tab-inactive">아키텍처</button>
                    </li>
                    <li class="mr-2">
                        <button id="tab-tech" class="inline-block p-4 border-b-2 rounded-t-lg tab-inactive">핵심 기술</button>
                    </li>
                    <li class="mr-2">
                        <button id="tab-setup" class="inline-block p-4 border-b-2 rounded-t-lg tab-inactive">설치 및 실행</button>
                    </li>
                    <li>
                        <button id="tab-gemini" class="inline-block p-4 border-b-2 rounded-t-lg tab-inactive">✨ AI 기능</button>
                    </li>
                </ul>
            </nav>

            <div id="content-container">
                <!-- Overview Section -->
                <div id="content-overview" class="content-section content-active">
                    <h2 class="text-2xl font-bold mb-4">프로젝트 개요</h2>
                    <p class="mb-6 text-gray-700">본 프로젝트는 Google AI(Gemini), Gmail, Google Calendar와 연동하여 반복적인 업무를 자동화하는 AI 비서 서비스입니다. LangChain/LangGraph를 활용한 Multi-Agent 아키텍처를 기반으로 사용자 요청의 의도를 파악하고, RAG를 통해 내부 문서를 참조하여 정확하고 풍부한 답변을 제공합니다. 사용자는 웹 UI를 통해 AI 비서와 대화하며 업무 효율성을 극대화할 수 있습니다.</p>
                    <div class="grid md:grid-cols-3 gap-4 text-center">
                        <div class="bg-teal-50 p-6 rounded-lg">
                            <span class="text-4xl">📧</span>
                            <h3 class="text-lg font-bold mt-2">Gmail 연동</h3>
                            <p class="text-sm text-gray-600">메일 검색, 요약, 분류 자동화</p>
                        </div>
                        <div class="bg-teal-50 p-6 rounded-lg">
                            <span class="text-4xl">📅</span>
                            <h3 class="text-lg font-bold mt-2">Calendar 연동</h3>
                            <p class="text-sm text-gray-600">일정 조회 및 요약</p>
                        </div>
                        <div class="bg-teal-50 p-6 rounded-lg">
                             <span class="text-4xl">🔍</span>
                            <h3 class="text-lg font-bold mt-2">RAG 기반 지식검색</h3>
                            <p class="text-sm text-gray-600">내부 문서 기반의 정확한 답변</p>
                        </div>
                    </div>
                </div>

                <!-- Architecture Section -->
                <div id="content-architecture" class="content-section">
                     <h2 class="text-2xl font-bold mb-2">대화형 아키텍처</h2>
                     <p class="mb-6 text-gray-700">아래 다이어그램의 각 구성 요소를 클릭하여 상세 설명을 확인하세요. 전체 시스템은 사용자의 요청을 받아 여러 전문 에이전트에게 작업을 분배하고, 최종 결과를 사용자에게 전달하는 흐름으로 동작합니다.</p>
                    <div class="lg:flex gap-6">
                        <div class="flex-grow grid grid-cols-3 gap-4 items-start">
                            <div class="col-span-1 flex flex-col items-center gap-4">
                                <div class="component-card cursor-pointer w-full p-4 bg-blue-100 text-blue-800 rounded-lg text-center border-2 border-blue-200" data-info="frontend">
                                    <h4 class="font-bold">Frontend</h4><p class="text-sm">(Streamlit)</p>
                                </div>
                            </div>
                            <div class="col-span-1 flex flex-col items-center gap-4">
                               <div class="component-card cursor-pointer w-full p-4 bg-green-100 text-green-800 rounded-lg text-center border-2 border-green-200" data-info="backend">
                                    <h4 class="font-bold">Backend</h4><p class="text-sm">(FastAPI)</p>
                                </div>
                            </div>
                             <div class="col-span-1 flex flex-col items-center gap-4">
                                <div class="component-card cursor-pointer w-full p-4 bg-purple-100 text-purple-800 rounded-lg text-center border-2 border-purple-200" data-info="master_agent">
                                    <h4 class="font-bold">Master Agent</h4><p class="text-sm">(LangGraph)</p>
                                </div>
                            </div>
                            <div class="col-span-3 text-center my-2">
                                <span class="text-2xl font-mono text-gray-400">↓ ↔ ↑</span>
                            </div>
                            <div class="col-span-3 grid grid-cols-3 gap-4">
                                <div class="component-card cursor-pointer p-3 bg-orange-100 text-orange-800 rounded-lg text-center border-2 border-orange-200" data-info="gmail_agent">
                                    <h4 class="font-semibold">Gmail Agent</h4>
                                </div>
                                <div class="component-card cursor-pointer p-3 bg-orange-100 text-orange-800 rounded-lg text-center border-2 border-orange-200" data-info="calendar_agent">
                                    <h4 class="font-semibold">Calendar Agent</h4>
                                </div>
                                 <div class="component-card cursor-pointer p-3 bg-orange-100 text-orange-800 rounded-lg text-center border-2 border-orange-200" data-info="rag_agent">
                                    <h4 class="font-semibold">RAG Agent</h4>
                                </div>
                            </div>
                             <div class="col-span-3 text-center my-2">
                                <span class="text-2xl font-mono text-gray-400">↓ ↔ ↑</span>
                            </div>
                            <div class="col-span-3 grid grid-cols-2 gap-4">
                                <div class="component-card cursor-pointer p-3 bg-gray-200 text-gray-800 rounded-lg text-center border-2 border-gray-300" data-info="tools">
                                    <h4 class="font-semibold">Tools</h4>
                                </div>
                                 <div class="component-card cursor-pointer p-3 bg-gray-200 text-gray-800 rounded-lg text-center border-2 border-gray-300" data-info="vector_store">
                                    <h4 class="font-semibold">Vector Store</h4>
                                </div>
                            </div>
                        </div>
                        <div id="architecture-info" class="lg:w-1/3 mt-6 lg:mt-0 p-4 bg-gray-100 rounded-lg h-full">
                            <h3 id="info-title" class="font-bold text-lg mb-2 text-gray-800">정보</h3>
                            <p id="info-description" class="text-gray-700">다이어그램의 구성 요소를 클릭하여 설명을 확인하세요.</p>
                        </div>
                    </div>
                </div>

                <!-- Core Technologies Section -->
                <div id="content-tech" class="content-section">
                    <h2 class="text-2xl font-bold mb-2">핵심 기술 스택</h2>
                     <p class="mb-6 text-gray-700">본 프로젝트는 최신 AI 및 웹 기술들을 유기적으로 결합하여 구성되었습니다. 각 기술은 특정 역할을 수행하며, 전체 시스템의 안정성과 확장성을 보장합니다.</p>
                    <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <div class="p-4 bg-gray-50 border rounded-lg">
                            <h3 class="font-bold text-teal-700">LangGraph</h3>
                            <p class="text-sm text-gray-600">상태(State)를 기반으로 여러 에이전트와 도구를 연결하여 복잡한 워크플로우를 생성합니다. Master Agent의 핵심 로직을 담당합니다.</p>
                        </div>
                        <div class="p-4 bg-gray-50 border rounded-lg">
                            <h3 class="font-bold text-teal-700">RAG (Retrieval-Augmented Generation)</h3>
                            <p class="text-sm text-gray-600">외부 데이터베이스(Vector Store)에서 관련 정보를 검색하여 LLM의 답변을 보강합니다. 이를 통해 최신 정보나 내부 문서에 기반한 정확한 답변 생성이 가능합니다.</p>
                        </div>
                        <div class="p-4 bg-gray-50 border rounded-lg">
                            <h3 class="font-bold text-teal-700">ReAct (Tool Agent)</h3>
                            <p class="text-sm text-gray-600">LLM이 스스로 생각(Reasoning)하고 행동(Action)을 결정하는 프레임워크입니다. Gmail, Calendar Agent는 이 방식을 통해 API를 동적으로 호출합니다.</p>
                        </div>
                        <div class="p-4 bg-gray-50 border rounded-lg">
                            <h3 class="font-bold text-teal-700">FastAPI</h3>
                            <p class="text-sm text-gray-600">Python 기반의 고성능 웹 프레임워크로, 백엔드 API 서버를 구축하는 데 사용됩니다.</p>
                        </div>
                        <div class="p-4 bg-gray-50 border rounded-lg">
                            <h3 class="font-bold text-teal-700">Streamlit</h3>
                            <p class="text-sm text-gray-600">데이터 과학자와 AI 엔지니어를 위한 프레임워크로, 빠르고 쉽게 대화형 UI를 개발할 수 있게 해줍니다.</p>
                        </div>
                         <div class="p-4 bg-gray-50 border rounded-lg">
                            <h3 class="font-bold text-teal-700">FAISS</h3>
                            <p class="text-sm text-gray-600">Facebook AI에서 개발한 라이브러리로, 대규모 벡터 데이터의 효율적인 유사도 검색을 지원합니다. Vector DB 구축에 사용됩니다.</p>
                        </div>
                    </div>
                </div>

                <!-- Setup Section -->
                <div id="content-setup" class="content-section">
                     <h2 class="text-2xl font-bold mb-2">설치 및 실행 가이드</h2>
                     <p class="mb-6 text-gray-700">아래 단계를 순서대로 따라하여 로컬 환경에서 AI 비서 서비스를 실행할 수 있습니다. 각 단계를 완료한 후 체크박스를 선택하여 진행 상황을 추적하세요.</p>
                    <div class="space-y-4">
                        <div class="setup-step border rounded-lg p-4">
                            <input type="checkbox" id="step1" class="mr-2 h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-600">
                            <label for="step1" class="font-bold text-lg cursor-pointer" onclick="toggleStep('details1')">1. Google Cloud 및 API 설정</label>
                            <div id="details1" class="hidden mt-2 pl-6 text-sm space-y-2 text-gray-600">
                                <p>1. Google Cloud Console에서 새 프로젝트를 생성합니다.</p>
                                <p>2. `Vertex AI API`, `Gmail API`, `Google Calendar API`를 활성화합니다.</p>
                                <p>3. API 키와 OAuth 2.0 클라이언트 ID를 생성합니다.</p>
                                <p>4. 다운로드한 OAuth 인증 정보 JSON 파일을 프로젝트 루트에 `credentials.json`으로 저장합니다.</p>
                            </div>
                        </div>
                        <div class="setup-step border rounded-lg p-4">
                             <input type="checkbox" id="step2" class="mr-2 h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-600">
                             <label for="step2" class="font-bold text-lg cursor-pointer" onclick="toggleStep('details2')">2. 프로젝트 환경 설정</label>
                             <div id="details2" class="hidden mt-2 pl-6 text-sm space-y-2 text-gray-600">
                                <p>1. 프로젝트 저장소를 복제(clone)하고 `.env` 파일을 생성합니다.</p>
                                <pre class="bg-gray-800 text-white p-2 rounded-md text-xs">cp .env.example .env</pre>
                                <p>2. `.env` 파일에 1단계에서 발급받은 API 키 등의 정보를 입력합니다.</p>
                             </div>
                        </div>
                        <div class="setup-step border rounded-lg p-4">
                             <input type="checkbox" id="step3" class="mr-2 h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-600">
                             <label for="step3" class="font-bold text-lg cursor-pointer" onclick="toggleStep('details3')">3. RAG 데이터 준비</label>
                            <div id="details3" class="hidden mt-2 pl-6 text-sm space-y-2 text-gray-600">
                                <p>1. `documents` 디렉토리에 AI가 참조할 텍스트 파일(e.g., sample_report.txt)을 추가합니다.</p>
                                <p>2. 필요한 Python 패키지를 설치하고, 데이터 처리 스크립트를 실행합니다.</p>
                                <pre class="bg-gray-800 text-white p-2 rounded-md text-xs">pip install -r server/requirements.txt\\npython -m server.rag.ingest</pre>
                                <p>→ `vector_store/faiss_index` 디렉토리에 벡터 DB가 생성됩니다.</p>
                            </div>
                        </div>
                         <div class="setup-step border rounded-lg p-4">
                             <input type="checkbox" id="step4" class="mr-2 h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-600">
                             <label for="step4" class="font-bold text-lg cursor-pointer" onclick="toggleStep('details4')">4. 애플리케이션 실행</label>
                             <div id="details4" class="hidden mt-2 pl-6 text-sm space-y-2 text-gray-600">
                                <p>1. 새 터미널에서 백엔드 서버를 실행합니다.</p>
                                <pre class="bg-gray-800 text-white p-2 rounded-md text-xs">uvicorn server.main:app --host 0.0.0.0 --port 8000 --reload</pre>
                                <p>2. 또 다른 새 터미널에서 프론트엔드 앱을 실행합니다.</p>
                                <pre class="bg-gray-800 text-white p-2 rounded-md text-xs">pip install -r app/requirements.txt\\nstreamlit run app/app.py</pre>
                                <p>3. 웹 브라우저에서 `http://localhost:8501` 주소로 접속합니다.</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Gemini AI Features Section -->
                <div id="content-gemini" class="content-section">
                    <h2 class="text-2xl font-bold mb-2">✨ Gemini AI 기반 기능</h2>
                    <p class="mb-6 text-gray-700">프로젝트에 대한 이해를 돕기 위해 Gemini AI를 활용한 동적 콘텐츠 생성 기능을 제공합니다. 궁금한 점을 AI에게 직접 물어보세요.</p>
                    
                    <div class="grid md:grid-cols-2 gap-8">
                        <!-- AI Explanation Helper -->
                        <div class="bg-gray-50 p-6 rounded-lg border">
                            <h3 class="text-xl font-bold mb-4">AI 설명 도우미</h3>
                            <p class="text-sm text-gray-600 mb-4">아래 목록에서 궁금한 기술 용어를 선택하고 버튼을 누르면, AI가 알기 쉽게 설명해 드립니다.</p>
                            <select id="tech-selector" class="w-full p-2 border border-gray-300 rounded-md mb-4">
                                <option value="LangGraph">LangGraph</option>
                                <option value="RAG">RAG (Retrieval-Augmented Generation)</option>
                                <option value="ReAct">ReAct (Tool Agent)</option>
                                <option value="FAISS">FAISS</option>
                                <option value="Multi-Agent System">Multi-Agent System</option>
                            </select>
                            <button id="explain-btn" class="w-full bg-teal-600 text-white font-bold py-2 px-4 rounded-md gemini-btn">설명 요청</button>
                        </div>
                        
                        <!-- Project Summary Generator -->
                        <div class="bg-gray-50 p-6 rounded-lg border">
                            <h3 class="text-xl font-bold mb-4">프로젝트 요약 생성기</h3>
                            <p class="text-sm text-gray-600 mb-4">원하는 요약 유형을 선택하면, AI가 이 프로젝트의 핵심 내용을 간추려 드립니다.</p>
                            <select id="summary-selector" class="w-full p-2 border border-gray-300 rounded-md mb-4">
                                <option value="한 문장 요약">한 문장 요약</option>
                                <option value="핵심 기능 3가지">핵심 기능 3가지</option>
                                <option value="비전문가용 요약">비전문가용 요약</option>
                                <option value="개발자용 기술 요약">개발자용 기술 요약</option>
                            </select>
                            <button id="summarize-btn" class="w-full bg-teal-600 text-white font-bold py-2 px-4 rounded-md gemini-btn">요약 요청</button>
                        </div>
                    </div>

                    <div id="gemini-output" class="mt-8 p-6 bg-blue-50 border border-blue-200 rounded-lg min-h-[120px]">
                        <p class="text-gray-500">AI의 답변이 여기에 표시됩니다.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const tabs = document.querySelectorAll('nav button');
        const contents = document.querySelectorAll('.content-section');

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(item => {
                    item.classList.remove('tab-active');
                    item.classList.add('tab-inactive');
                });
                tab.classList.add('tab-active');
                tab.classList.remove('tab-inactive');
                
                const targetId = tab.id.replace('tab-', 'content-');
                contents.forEach(content => {
                    content.classList.remove('content-active');
                });
                document.getElementById(targetId).classList.add('content-active');
            });
        });

        const architectureInfo = {
            frontend: { title: 'Frontend (Streamlit)', description: '사용자가 AI와 상호작용하는 웹 인터페이스입니다. 사용자의 메시지를 백엔드 API로 전송하고, 응답을 받아 화면에 표시하는 역할을 합니다.' },
            backend: { title: 'Backend (FastAPI)', description: 'Streamlit 앱의 요청을 받아 처리하는 API 서버입니다. 실제 AI 로직이 실행되는 관문입니다.' },
            master_agent: { title: 'Master Agent (LangGraph)', description: '사용자의 질문을 가장 먼저 받아 의도를 분석하고, 어떤 전문가 에이전트에게 작업을 위임할지 결정하는 오케스트레이터 역할을 합니다.' },
            gmail_agent: { title: 'Gmail Agent', description: 'Google Gmail API를 사용하여 메일 요약, 검색, 분류 등의 작업을 수행하는 전문가 에이전트입니다.' },
            calendar_agent: { title: 'Calendar Agent', description: 'Google Calendar API를 사용하여 일정 조회, 요약 등의 작업을 수행하는 전문가 에이전트입니다.' },
            rag_agent: { title: 'RAG Agent', description: 'FAISS 기반의 Vector DB에 저장된 내부 문서를 검색하여 질문에 답변하는 전문가 에이전트입니다.' },
            tools: { title: 'Tools', description: '각 에이전트가 사용하는 도구(함수)의 집합입니다. 실제 Google API를 호출하거나 Vector DB를 검색하는 구체적인 기능들로 구성됩니다.' },
            vector_store: { title: 'Vector Store (FAISS)', description: 'RAG를 위해 텍스트 문서들이 임베딩(벡터화)되어 저장되는 공간입니다. AI가 외부 지식을 참조할 수 있도록 돕습니다.' }
        };

        const componentCards = document.querySelectorAll('.component-card');
        const infoTitle = document.getElementById('info-title');
        const infoDescription = document.getElementById('info-description');

        componentCards.forEach(card => {
            card.addEventListener('click', () => {
                const infoKey = card.dataset.info;
                const info = architectureInfo[infoKey];
                infoTitle.textContent = info.title;
                infoDescription.textContent = info.description;
                componentCards.forEach(c => c.classList.remove('ring-2', 'ring-teal-500'));
                card.classList.add('ring-2', 'ring-teal-500');
            });
        });
        
        function toggleStep(detailsId) {
            document.getElementById(detailsId).classList.toggle('hidden');
        }

        // --- Gemini AI Feature Logic ---
        const geminiOutput = document.getElementById('gemini-output');
        const explainBtn = document.getElementById('explain-btn');
        const summarizeBtn = document.getElementById('summarize-btn');
        const techSelector = document.getElementById('tech-selector');
        const summarySelector = document.getElementById('summary-selector');
        
        const projectContext = `
            프로젝트 명: AI 업무 자동화 비서 (ai-assist-google)
            핵심 목표: Google AI(Gemini), Gmail, Google Calendar와 연동하여 반복적인 업무(메일 정리, 일정 조정, 보고서 요약 등)를 자동화하는 AI 비서 서비스 개발.
            주요 기술:
            - Frontend: Streamlit
            - Backend: FastAPI
            - AI Agent 아키텍처: LangChain, LangGraph 기반의 Multi-Agent 시스템
            - 핵심 에이전트: Master Agent (작업 라우팅), Gmail Agent, Calendar Agent, RAG Agent (내부 문서 검색)
            - 데이터베이스: FAISS 기반 Vector Store
            - 인증: Google OAuth 2.0
        `;

        async function callGemini(prompt) {
            geminiOutput.innerHTML = '<div class="flex items-center justify-center"><div class="loader"></div><p class="ml-4 text-gray-600">AI가 답변을 생성 중입니다...</p></div>';
            
            const apiKey = ""; // API 키는 Canvas 환경에서 자동으로 제공됩니다.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    role: "user",
                    parts: [{ text: prompt }]
                }]
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API 호출 실패: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    geminiOutput.innerHTML = `<p class="text-gray-800">${text.replace(/\\n/g, '<br>')}</p>`;
                } else {
                    throw new Error("API 응답에서 유효한 콘텐츠를 찾을 수 없습니다.");
                }

            } catch (error) {
                console.error("Gemini API 호출 중 오류 발생:", error);
                geminiOutput.innerHTML = `<p class="text-red-600">오류가 발생했습니다: ${error.message}</p>`;
            }
        }

        explainBtn.addEventListener('click', () => {
            const selectedTech = techSelector.value;
            const prompt = \\`
                당신은 AI 기술 전문가입니다. 아래의 기술 용어에 대해 IT 분야에 익숙하지 않은 사람도 이해할 수 있도록 쉽고 명확하게 설명해주세요. 비유를 들어 설명하면 더욱 좋습니다.

                기술 용어: "${selectedTech}"

                설명:
            \\`;
            callGemini(prompt);
        });

        summarizeBtn.addEventListener('click', () => {
            const summaryType = summarySelector.value;
            const prompt = \`
                당신은 주어진 프로젝트 정보를 분석하여 명확하게 요약하는 AI 전문가입니다.
                
                아래 프로젝트 정보를 바탕으로, 요청된 유형에 맞게 요약문을 한국어로 생성해주세요.

                [프로젝트 정보]
                ${projectContext}

                [요약 요청 유형]
                "${summaryType}"

                요약문:
            \`;
            callGemini(prompt);
        });

    </script>
</body>
</html>
'''

# --- 파일 생성 로직 ---

def create_project_files():
    '''프로젝트 디렉토리와 파일을 생성합니다.'''
    
    # 파일 경로와 내용을 매핑
    files_to_create = {
        "ai-assist-google/README.md": README_MD_CONTENT,
        "ai-assist-google/.env.example": ENV_EXAMPLE_CONTENT,
        "ai-assist-google/app/app.py": APP_PY_CONTENT,
        "ai-assist-google/app/requirements.txt": APP_REQUIREMENTS_TXT_CONTENT,
        "ai-assist-google/server/main.py": SERVER_MAIN_PY_CONTENT,
        "ai-assist-google/server/requirements.txt": SERVER_REQUIREMENTS_TXT_CONTENT,
        "ai-assist-google/server/api/chat.py": API_CHAT_PY_CONTENT,
        "ai-assist-google/server/agents/__init__.py": "",
        "ai-assist-google/server/agents/state.py": AGENTS_STATE_PY_CONTENT,
        "ai-assist-google/server/agents/master_agent.py": AGENTS_MASTER_AGENT_PY_CONTENT,
        "ai-assist-google/server/agents/specialist_agents.py": AGENTS_SPECIALIST_AGENTS_PY_CONTENT,
        "ai-assist-google/server/core/config.py": CORE_CONFIG_PY_CONTENT,
        "ai-assist-google/server/rag/__init__.py": "",
        "ai-assist-google/server/rag/ingest.py": RAG_INGEST_PY_CONTENT,
        "ai-assist-google/server/rag/retriever.py": RAG_RETRIEVER_PY_CONTENT,
        "ai-assist-google/server/tools/__init__.py": "",
        "ai-assist-google/server/tools/google_services.py": TOOLS_GOOGLE_SERVICES_PY_CONTENT,
        "ai-assist-google/documents/sample_report.txt": SAMPLE_REPORT_TXT_CONTENT,
        "ai-assist-google/vector_store/faiss_index/.gitkeep": "",
        "ai-assist-google/interactive_dashboard.html": INTERACTIVE_DASHBOARD_HTML_CONTENT
    }

    print("프로젝트 파일 생성을 시작합니다...")

    for file_path, content in files_to_create.items():
        # 디렉토리 생성
        dir_name = os.path.dirname(file_path)
        if not os.path.exists(dir_name):
            os.makedirs(dir_name)
            print(f"  디렉토리 생성: {dir_name}")

        # 파일 생성 및 내용 작성
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                # textwrap.dedent를 사용하여 공통 들여쓰기 제거
                f.write(textwrap.dedent(content).strip())
            print(f"  ✓ 파일 생성: {file_path}")
        except IOError as e:
            print(f"  ✗ 파일 생성 오류: {file_path} ({e})")

    print("\n프로젝트 생성이 완료되었습니다!")
    print("이제 'ai-assist-google' 디렉토리를 VS Code에서 열고 README.md 파일을 참고하여 개발을 시작하세요.")

if __name__ == "__main__":
    create_project_files()

  ```
"""